* Converting my emacs configuration to literate programming
:PROPERTIES:
:tangle:   yes
:END:

Some references:

- [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge - Effective Emacs]]
- [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][A Gentle Introduction to CEDET]]
- [[https://github.com/sachac/.emacs.d][Sacha Chua's emacs.d]]
- [[http://sachachua.com/blog/2014/12/emacs-configuration-use-package/][Sacha explains use-package]]
- [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][Sebastian Wiesner's configuration with use-package]]

#+BEGIN_SRC elisp
(require 'use-package)
#+END_SRC

** Markdown editing & preview

#+BEGIN_SRC elisp :results silent
(defun markdown-preview-file ()
  "Run Marked on the current file and revert the buffer"
  (interactive)
  (shell-command
   (format "open -a /Applications/Marked\\ 2.app %s"
           (shell-quote-argument (buffer-file-name))))
  )
#+END_SRC

** Ruby development

*** [[https://github.com/purcell/ruby-hash-syntax][ruby-hash-syntax]]

Toggle ruby hash syntax between classic and 1.9 styles.

#+BEGIN_SRC elisp :results silent
  (use-package ruby-hash-syntax
    :ensure t
  )
#+END_SRC

** Navigation

Lucas Bonnet's buffer-move package.

#+BEGIN_SRC elisp
  (use-package buffer-move
    :ensure t
    :bind (
           ("C-H-<left>" . buf-move-left)
           ("C-H-<right>" . buf-move-right)
           )
    )
#+END_SRC

#+RESULTS:

** Various private commands

#+BEGIN_SRC elisp
(defun upcase-region-or-word (numwords)
  "Upcase a region if selected, otherwise the next word (or words if prefix argument is provided)."
  (interactive "p")
  (if (region-active-p)
      (upcase-region (region-beginning) (region-end))
    (upcase-word numwords)))


;; http://oremacs.com/2015/01/14/repeatable-commands/
(defun def-rep-command (alist)
  "Return a lambda that calls the first function of ALIST.
It sets the transient map to all functions of ALIST."
  (lexical-let ((keymap (make-sparse-keymap))
                (func (cdar alist)))
    (mapc (lambda (x)
            (define-key keymap (car x) (cdr x)))
          alist)
    (lambda (arg)
      (interactive "p")
      (funcall func arg)
      (set-transient-map keymap t))))
#+END_SRC

** Copy region without newlines

- [[Copy region from emacs without newlines][my stackexchange post]]
- [[https://gist.github.com/xahlee/d364cbbff9b3abd12d29][improved version from Xah Lee]]

#+BEGIN_SRC elisp
(defun compact-uncompact-block ()
  "Remove or add line ending chars on current paragraph.
This command is similar to a toggle of `fill-paragraph'.
When there is a text selection, act on the region."
  (interactive)

  ;; This command symbol has a property “'stateIsCompact-p”.
  (let (currentStateIsCompact (bigFillColumnVal 90002000) (deactivate-mark nil))
    ;; 90002000 is just random. you can use `most-positive-fixnum'

    (save-excursion
      ;; Determine whether the text is currently compact.
      (setq currentStateIsCompact
            (if (eq last-command this-command)
                (get this-command 'stateIsCompact-p)
              (if (> (- (line-end-position) (line-beginning-position)) fill-column) t nil) ) )

      (if (region-active-p)
          (if currentStateIsCompact
              (fill-region (region-beginning) (region-end))
            (let ((fill-column bigFillColumnVal))
              (fill-region (region-beginning) (region-end))) )
        (if currentStateIsCompact
            (fill-paragraph nil)
          (let ((fill-column bigFillColumnVal))
            (fill-paragraph nil)) ) )

      (put this-command 'stateIsCompact-p (if currentStateIsCompact nil t)) ) ) )

(defun my-copy-simple (&optional beg end)
  "Save the current region (or line) to the `kill-ring' after stripping extra whitespace and new lines"
  (interactive
   (if (region-active-p)
       (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-end-position))))
  (let ((my-text (buffer-substring-no-properties beg end)))
    (with-temp-buffer
      (insert my-text)
      (goto-char 1)
      (while (looking-at "[ \t\n]")
        (delete-char 1))
      (let ((fill-column 9333999))
        (fill-region (point-min) (point-max)))
      (kill-region (point-min) (point-max)))))

;; bindings
(global-set-key (kbd "C-c q") 'compact-uncompact-block)
(global-set-key (kbd "s-C") 'my-copy-simple)
#+END_SRC

** Highlight indentation columns in code

#+BEGIN_SRC elisp
  (use-package highlight-indentation
    :ensure t
    :config
    (progn
      (set-face-background 'highlight-indentation-face "#222")
      (set-face-background 'highlight-indentation-current-column-face "#444")
      (add-hook 'prog-mode-hook
                (lambda ()
                  (highlight-indentation-mode)
                  (highlight-indentation-current-column-mode)
                  ))
      )
    )
#+END_SRC

** Database connections for my projects

- [[https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client/][setting up emacs as a SQL client]]

#+BEGIN_SRC elisp
(setq sql-connection-alist
      '((schoolistry (sql-product 'postgres)
                     (sql-port 5432)
                     (sql-server "localhost")
                     (sql-user "jmay")
                     (sql-password "")
                     (sql-database "schoolistry"))
        (schoolistry-prod (sql-product 'postgres)
                          (sql-port 5432)
                          (sql-server "remote")
                          (sql-user "remote")
                          (sql-password "remote")
                          (sql-database "postgres"))
;; using ssh port forwarding
;; requires password entry in buffer, but displays no prompt
        (veriphyr (sql-product 'postgres)
                  (sql-port 5100)
                  (sql-server "localhost")
                  (sql-user "jmay")
                  (sql-database "g1"))
        )
      )

(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (toggle-truncate-lines t)))
#+END_SRC
